#if UNITY_EDITOR\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing UnityEditor;\nusing UnityEngine;\n\nnamespace DemonShop.Editor\n{\n    public static class DP_OcclusionTools\n    {\n        private static float _expandPct = 2f;\n        private static float _occluder = 1.0f;\n        private static float _hole = 0.25f;\n        private static int _backface = 100;\n        private static bool _selOnly = false;\n\n        public static void DrawGUI()\n        {\n            EditorGUILayout.HelpBox(DP_Loc.T("occIntro"), MessageType.None);\n\n            if (GUILayout.Button(DP_Loc.T("analyzeSuggest")))\n            {\n                AnalyzeAndSuggest();\n                EditorUtility.DisplayDialog("Suggested",\n                    $"{DP_Loc.T("occOcc")} ~{_occluder:0.###} m\n{DP_Loc.T("occHole")} ~{_hole:0.###} m\n{DP_Loc.T("occBack")} ~{_backface}%",\n                    DP_Loc.T("ok"));\n            }\n\n            GUILayout.Label("Suggested", EditorStyles.boldLabel);\n            _occluder  = EditorGUILayout.Slider(DP_Loc.T("occOcc"),  _occluder, 0.05f, 10f);\n            _hole      = EditorGUILayout.Slider(DP_Loc.T("occHole"), _hole,     0.02f, 2f);\n            _backface  = EditorGUILayout.IntSlider(DP_Loc.T("occBack"), _backface, 0, 100);\n\n            GUILayout.Space(4);\n            GUILayout.Label("Static Flags", EditorStyles.boldLabel);\n            _selOnly = EditorGUILayout.ToggleLeft(DP_Loc.T("selOnly"), _selOnly);\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(DP_Loc.T("markOcc"))) SetStaticFlags(StaticEditorFlags.OccluderStatic, true);\n            if (GUILayout.Button(DP_Loc.T("markOcee"))) SetStaticFlags(StaticEditorFlags.OccludeeStatic, true);\n            if (GUILayout.Button(DP_Loc.T("clearOcc")))\n            {\n                SetStaticFlags(StaticEditorFlags.OccluderStatic, false);\n                SetStaticFlags(StaticEditorFlags.OccludeeStatic, false);\n            }\n            EditorGUILayout.EndHorizontal();\n\n            GUILayout.Space(4);\n            GUILayout.Label("Occlusion Areas", EditorStyles.boldLabel);\n            _expandPct = EditorGUILayout.Slider(DP_Loc.T("boundsExpandPct"), _expandPct, 0, 20);\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(DP_Loc.T("createFromSel"))) CreateAreasFromSelection();\n            if (GUILayout.Button(DP_Loc.T("clearAllAreas"))) ClearAllAreas();\n            EditorGUILayout.EndHorizontal();\n\n            GUILayout.Space(4);\n            GUILayout.Label("Bake", EditorStyles.boldLabel);\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(DP_Loc.T("openOccWin"))) OpenOcclusionWindow();\n            if (GUILayout.Button(DP_Loc.T("bakeBg"))) TryBakeInBackground();\n            EditorGUILayout.EndHorizontal();\n\n            EditorGUILayout.HelpBox(DP_Loc.T("tipOcc"), MessageType.Info);\n        }\n\n        private static void AnalyzeAndSuggest()\n        {\n            var targets = new List<Bounds>();\n            IEnumerable<Renderer> rends;\n            IEnumerable<Collider> cols;\n\n            if (_selOnly && Selection.transforms != null && Selection.transforms.Length > 0)\n            {\n                var set = new HashSet<GameObject>(Selection.transforms.SelectMany(t => t.GetComponentsInChildren<Transform>(true)).Select(t => t.gameObject));\n                rends = UnityEngine.Object.FindObjectsOfType<Renderer>(true).Where(r => set.Contains(r.gameObject));\n                cols  = UnityEngine.Object.FindObjectsOfType<Collider>(true).Where(c => set.Contains(c.gameObject));\n            }\n            else\n            {\n                rends = UnityEngine.Object.FindObjectsOfType<Renderer>(true);\n                cols  = UnityEngine.Object.FindObjectsOfType<Collider>(true);\n            }\n\n            foreach (var r in rends){ if (!r || !r.gameObject) continue; if (!IsStatic(r.gameObject)) continue; targets.Add(r.bounds); }\n            foreach (var c in cols){ if (!c || !c.gameObject) continue; if (!IsStatic(c.gameObject)) continue; targets.Add(c.bounds); }\n            if (targets.Count == 0){ _occluder = 1f; _hole = 0.25f; _backface = 100; return; }\n\n            var minDims = new List<float>(); var majorDims = new List<float>();\n            foreach (var b in targets)\n            {\n                var s = b.size; var mins = new[]{ s.x, s.y, s.z }.OrderBy(v=>v).ToArray();\n                minDims.Add(Mathf.Max(0.01f, (float)mins[0]));\n                majorDims.Add(Mathf.Max(mins[1], mins[2]));\n            }\n            float Q(IList<float> a, float p){ if (a.Count==0) return 0f; var arr=a.OrderBy(x=>x).ToArray(); float idx=Mathf.Clamp01(p)*(arr.Length-1); int i0=Mathf.FloorToInt(idx); int i1=Mathf.Min(arr.Length-1,i0+1); float t=idx-i0; return Mathf.Lerp(arr[i0],arr[i1],t); }\n            var thickQ = Q(minDims, 0.75f); var holeQ = Q(majorDims, 0.10f);\n            _occluder = Mathf.Clamp(thickQ, 0.1f, 5f);\n            _hole     = Mathf.Clamp(holeQ * 0.5f, 0.05f, 1.0f);\n            _backface = 100;\n        }\n\n        private static bool IsStatic(GameObject go)\n        {\n            var flags = GameObjectUtility.GetStaticEditorFlags(go);\n            return (flags & (StaticEditorFlags.BatchingStatic | StaticEditorFlags.OccluderStatic | StaticEditorFlags.OccludeeStatic | StaticEditorFlags.NavigationStatic | StaticEditorFlags.ContributeGI)) != 0;\n        }\n\n        private static void SetStaticFlags(StaticEditorFlags flag, bool on)\n        {\n            var targets = new List<GameObject>();\n            if (_selOnly && Selection.transforms != null && Selection.transforms.Length > 0)\n            {\n                foreach (var t in Selection.transforms)\n                    targets.AddRange(t.GetComponentsInChildren<Transform>(true).Select(x=>x.gameObject));\n            }\n            else targets.AddRange(UnityEngine.Object.FindObjectsOfType<Transform>(true).Select(x=>x.gameObject));\n            targets = targets.Distinct().ToList();\n\n            Undo.IncrementCurrentGroup(); int ug = Undo.GetCurrentGroup();\n            foreach (var go in targets)\n            {\n                var flags = GameObjectUtility.GetStaticEditorFlags(go);\n                if (on) flags |= flag; else flags &= ~flag;\n                GameObjectUtility.SetStaticEditorFlags(go, flags);\n            }\n            Undo.CollapseUndoOperations(ug);\n            EditorUtility.DisplayDialog("Static Flags", $"{(on?"Set":"Cleared")} {flag} for {targets.Count} objects.", DP_Loc.T("ok"));\n        }\n\n        private static void CreateAreasFromSelection()\n        {\n            if (Selection.transforms == null || Selection.transforms.Length == 0)\n            { EditorUtility.DisplayDialog("No Selection", "Select one or more parents/objects.", DP_Loc.T("ok")); return; }\n            var b = DP_Utils.CollectBounds(Selection.transforms, true, true);\n            if (!b.HasValue)\n            { EditorUtility.DisplayDialog("No Bounds", "Selected objects have no renderer/collider bounds.", DP_Loc.T("ok")); return; }\n            var bounds = b.Value; bounds.Expand(bounds.size * (_expandPct/100f));\n\n            Undo.IncrementCurrentGroup(); int ug = Undo.GetCurrentGroup();\n            var root = new GameObject("__OcclusionAreas"); Undo.RegisterCreatedObjectUndo(root, "Create OcclusionAreas Root");\n            root.transform.position = bounds.center;\n\n            var go = new GameObject("OcclusionArea"); Undo.RegisterCreatedObjectUndo(go, "Create OcclusionArea");\n            go.transform.SetParent(root.transform, false);\n            var oa = go.AddComponent<OcclusionArea>();\n            oa.center = Vector3.zero; oa.size = bounds.size;\n\n            Undo.CollapseUndoOperations(ug);\n            Selection.activeGameObject = go;\n            EditorGUIUtility.PingObject(go);\n        }\n\n        private static void ClearAllAreas()\n        {\n            var areas = UnityEngine.Object.FindObjectsOfType<OcclusionArea>(true);\n            Undo.IncrementCurrentGroup(); int ug = Undo.GetCurrentGroup();\n            int n=0; foreach (var a in areas){ if (a) Undo.DestroyObjectImmediate(a.gameObject); n++; }\n            Undo.CollapseUndoOperations(ug);\n            EditorUtility.DisplayDialog("Clear Areas", $"Removed: {n}", DP_Loc.T("ok"));\n        }\n\n        private static void OpenOcclusionWindow()\n        {\n            var t = Type.GetType("UnityEditor.OcclusionCullingWindow,UnityEditor");\n            if (t != null){ EditorWindow.GetWindow(t, true, "Occlusion Culling").Show(); }\n            else EditorUtility.DisplayDialog("Info","Cannot find Occlusion window type. Open via Window > Rendering > Occlusion Culling.", DP_Loc.T("ok"));\n        }\n\n        private static void TryBakeInBackground()\n        {\n            var asm = typeof(UnityEditor.Editor).Assembly;\n            var t = asm.GetType("UnityEditor.SceneManagement.StaticOcclusionCulling");\n            if (t == null){ EditorUtility.DisplayDialog("Not Supported","API not found. Please bake from Occlusion window.", DP_Loc.T("ok")); return; }\n            var m = t.GetMethod("GenerateInBackground", BindingFlags.Static|BindingFlags.Public|BindingFlags.NonPublic);\n            if (m == null){ EditorUtility.DisplayDialog("Not Supported","GenerateInBackground API not available in this Unity. Please bake manually.", DP_Loc.T("ok")); return; }\n\n            try{ m.Invoke(null, null); EditorUtility.DisplayDialog("Baking", "Occlusion baking started in background.\nCheck progress in Occlusion window.", DP_Loc.T("ok")); }\n            catch(Exception e){ Debug.LogWarning(e); EditorUtility.DisplayDialog("Failed", "Start bake failed. Please open Occlusion window and bake manually.", DP_Loc.T("ok")); }\n        }\n    }\n}\n#endif