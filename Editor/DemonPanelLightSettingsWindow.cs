#if UNITY_EDITOR\nusing UnityEditor;\nusing UnityEngine;\nusing DemonShop.Editor;\n\nnamespace DemonShop.Editor\n{\n    public class DemonPanelLightWindow : EditorWindow\n    {\n        private Vector2 _scroll;\n        private int _tab = 0;\n        private static GUIContent[] _tabs;\n\n        [MenuItem("DemonShop/DemonPanel/Light Settings", false, 11)]\n        public static void Open()\n        {\n            DP_Loc.Init();\n            DP_PackageDetector.Ensure();\n            var w = GetWindow<DemonPanelLightWindow>();\n            w.titleContent = new GUIContent("Light Settings");\n            w.minSize = new Vector2(700, 540);\n            w.Show();\n        }\n\n        private void OnEnable() => BuildTabs();\n\n        private void BuildTabs()\n        {\n            _tabs = new[]\n            {\n                new GUIContent("Probes"),\n                new GUIContent(DP_Loc.T("tabVRCLV")),\n                new GUIContent(DP_Loc.T("tabBakery")),\n                new GUIContent(DP_Loc.T("tabOcclusion")),\n                new GUIContent(DP_Loc.T("tabIntegration")),\n            };\n        }\n\n        private void OnGUI()\n        {\n            // NOTE: 顶栏：标题 + 语言 // translated\n            using (new EditorGUILayout.HorizontalScope(EditorStyles.toolbar))\n            {\n                GUILayout.Label("Light Settings", EditorStyles.boldLabel);\n                GUILayout.FlexibleSpace();\n                GUILayout.Label(DP_Loc.T("language") + ":", GUILayout.Width(70));\n                var cur = (int)DP_Loc.Lang;\n                var next = EditorGUILayout.Popup(cur, DP_Loc.LangNames, GUILayout.Width(120));\n                if (next != cur) { DP_Loc.Lang = (DP_Loc.Language)next; BuildTabs(); }\n            }\n\n            // NOTE: Tab 工具条（可自动分行） // translated\n            DrawToolbarWrapped(position.width - 8);\n\n            _scroll = EditorGUILayout.BeginScrollView(_scroll);\n\n            switch (_tab)\n            {\n                case 0:\n                    GUILayout.Space(6);\n                    GUILayout.Label(DP_Loc.T("probeHeader"), EditorStyles.boldLabel);\n                    DP_ProbeTools.DrawGUI();\n                    break;\n\n                case 1:\n                    DP_VRCLVPage.DrawGUI();\n                    break;\n\n                case 2:\n                    GUILayout.Space(6);\n                    GUILayout.Label(DP_Loc.T("tabBakery"), EditorStyles.boldLabel);\n                    EditorGUILayout.HelpBox(DP_Loc.T("bakIntro"), MessageType.None);\n                    DP_BakeryTools.DrawGUI();\n                    break;\n\n                case 3:\n                    GUILayout.Space(6);\n                    GUILayout.Label(DP_Loc.T("occHeader"), EditorStyles.boldLabel);\n                    // NOTE: 去重：不再额外显示介绍行，留给 DP_OcclusionTools.DrawGUI() 里的介绍 // translated\n                    DP_OcclusionTools.DrawGUI();\n\n                    GUILayout.Space(10);\n                    GUILayout.Label(DP_Loc.T("roomsHeader"), EditorStyles.boldLabel);\n                    // NOTE: 同理，Rooms 的介绍由 DP_OcclusionRooms.DrawGUI() 自己负责 // translated\n                    DP_OcclusionRooms.DrawGUI();\n                    break;\n\n                case 4:\n                    GUILayout.Space(6);\n                    GUILayout.Label(DP_Loc.T("integrationHeader"), EditorStyles.boldLabel);\n                    DP_ProbeTools.DrawIntegrationBlock();\n                    DP_LVAdvisor.DrawIntegrationTail();\n                    break;\n            }\n\n            EditorGUILayout.EndScrollView();\n        }\n\n        // --------- Responsive toolbar rendering ----------\n        // NOTE: 思路：按按钮实际尺寸累加；若即将溢出当行宽度，则自动换行起一条新的 toolbar 行。 // translated\n        private void DrawToolbarWrapped(float maxWidth)\n        {\n            float used = 0f;\n            BeginToolbarRow();\n            for (int i = 0; i < _tabs.Length; i++)\n            {\n                var gc = _tabs[i];\n                // NOTE: 使用 toolbar 样式测算宽度，留一点左右边距余量 // translated\n                float w = Mathf.Ceil(EditorStyles.toolbarButton.CalcSize(gc).x) + 12f;\n\n                // If the row can't fit the next item, wrap.\n                if (used > 0f && used + w > maxWidth)\n                {\n                    EndToolbarRow();\n                    BeginToolbarRow();\n                    used = 0f;\n                }\n\n                bool on = _tab == i;\n                if (GUILayout.Toggle(on, gc, EditorStyles.toolbarButton, GUILayout.Width(w)))\n                    _tab = i;\n\n                used += w;\n            }\n            GUILayout.FlexibleSpace();\n            EndToolbarRow();\n        }\n\n        private void BeginToolbarRow()\n        {\n            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);\n        }\n\n        private void EndToolbarRow()\n        {\n            EditorGUILayout.EndHorizontal();\n        }\n    }\n}\n#endif