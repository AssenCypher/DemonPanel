#if UNITY_EDITOR\nusing UnityEditor;\nusing UnityEngine;\nusing System;\nusing System.Linq;\nusing System.Reflection;\nusing System.Collections.Generic;\n\nnamespace DemonShop.Editor\n{\n    /// <summary>\n    // NOTE: / Bakery 页签：打开 Render Lightmaps、全局灯光工具（收集/* Block comment translated:  */转换）、Area 修复、Static 扫描器。 // translated\n    // NOTE: /* Block comment translated: 全部通过反射做存在性检测；未安装 Bakery */ VRC SDK 也不会编译失败。 // translated\n    /// </summary>\n    public static class DP_BakeryTools\n    {\n        // NOTE: —— 对外可读状态（被其它面板引用） —— // translated\n        public static bool Installed { get { Detect(); return _hasBakery; } }\n\n        // NOTE: —— 内部缓存 —— // translated\n        private static bool _hasBakery;\n        private static string _detMsg;\n\n        // NOTE: —— 全局灯光工具 UI 状态 —— // translated\n        private static int _scope = 0; // 0: whole scene, 1: selection\n        private static bool _unpackPrefabs = true;\n        private static bool _groupUnder = true;\n        private static string _groupName = "Bakery_Lights";\n        private static bool _ignoreDirectional = true;\n        private static bool _disableOriginal = true;\n\n        // NOTE: —— Static 扫描器缓存与选项 —— // translated\n        private static readonly List<GameObject> _likelyStaticNotStatic = new();\n        private static readonly List<GameObject> _likelyDynamicStaticOn = new();\n        private static bool _setAllFlags = true;\n\n        // NOTE: 更保守/* Block comment translated: 激进的可选项 *// translated\n        private static bool _includeRendererOnly = true;   //* Block comment translated: NOTE: 无 Collider 的渲染网格也参与扫描 *// translated\n        private static bool _dynAnimator = true;           //* Block comment translated: NOTE: Animator 视为动态 *// translated\n        private static bool _dynAudio = true;              //* Block comment translated: NOTE: AudioSource 视为动态 *// translated\n        private static bool _dynParticles = false;         //* Block comment translated: NOTE: ParticleSystem 视为动态（默认关） *// translated\n        private static bool _dynReflProbe = false;         //* Block comment translated: NOTE: ReflectionProbe 视为动态（默认关） *// translated\n\n        static DP_BakeryTools() { Detect(); }\n\n        private static void Detect()\n        {\n            _hasBakery =\n                DP_Utils.GetTypeByName("ftBuildGraphics") != null ||\n                DP_Utils.GetTypeByName("ftLightmaps") != null ||\n                DP_Utils.GetTypeByName("ftGlobalStorage") != null ||\n                DP_Utils.GetTypeByName("ftLight") != null;\n\n            _detMsg = DP_Loc.T("bakDetect") + (_hasBakery ? "Yes" : "No");\n        }\n\n        public static void DrawGUI()\n        {\n            Detect();\n\n            EditorGUILayout.HelpBox(_detMsg, _hasBakery ? MessageType.Info : MessageType.Warning);\n\n            using (new EditorGUI.DisabledScope(!_hasBakery))\n            {\n                if (GUILayout.Button(DP_Loc.T("bakOpen"), GUILayout.Height(22)))\n                    OpenBakeryRenderWindow();\n\n                GUILayout.Space(6);\n                GUILayout.Label(DP_Loc.T("bakGlobal"), EditorStyles.boldLabel);\n\n                using (new EditorGUILayout.HorizontalScope())\n                {\n                    GUILayout.Label(DP_Loc.T("bakScope"), GUILayout.Width(60));\n                    _scope = EditorGUILayout.Popup(_scope, new[] { DP_Loc.T("bakScopeScene"), DP_Loc.T("bakScopeSel") }, GUILayout.Width(180));\n                    _unpackPrefabs = EditorGUILayout.ToggleLeft(DP_Loc.T("bakUnpack"), _unpackPrefabs);\n                }\n\n                using (new EditorGUILayout.HorizontalScope())\n                {\n                    _groupUnder = EditorGUILayout.ToggleLeft(DP_Loc.T("bakGroupUnder"), _groupUnder, GUILayout.Width(160));\n                    using (new EditorGUI.DisabledScope(!_groupUnder))\n                    {\n                        GUILayout.Label(DP_Loc.T("bakGroupName"), GUILayout.Width(80));\n                        _groupName = EditorGUILayout.TextField(_groupName);\n                    }\n                }\n\n                using (new EditorGUILayout.HorizontalScope())\n                {\n                    _ignoreDirectional = EditorGUILayout.ToggleLeft(DP_Loc.T("bakIgnoreDir"), _ignoreDirectional);\n                    _disableOriginal   = EditorGUILayout.ToggleLeft(DP_Loc.T("bakDisableOrig"), _disableOriginal);\n                }\n\n                //* Block comment translated: NOTE: —— 这里开始使用“自动换行按钮行” —— *// // translated\n                using (var row = new AutoRow(EditorGUIUtility.currentViewWidth))\n                {\n                    row.Button(DP_Loc.T("bakCollectGroup"), CollectAndGroup);\n                    row.Button(DP_Loc.T("bakConvertAll"),  ConvertAllToBakery);\n                }\n\n                GUILayout.Space(6);\n                GUILayout.Label(DP_Loc.T("bakFix"), EditorStyles.boldLabel);\n\n                using (var row = new AutoRow(EditorGUIUtility.currentViewWidth))\n                {\n                    row.Button(DP_Loc.T("bakFixArea"), () => ConvertUnityAreaToBakeryOnSelection());\n                    row.Button(DP_Loc.T("bakRunSel"), () => ConvertUnityAreaToBakeryOnSelection());\n                }\n\n                // —— Static scanner ——\n                GUILayout.Space(10);\n                GUILayout.Label(DP_Loc.T("ssHeader"), EditorStyles.boldLabel);\n                EditorGUILayout.HelpBox(DP_Loc.T("ssIntro"), MessageType.None);\n\n                using (var row = new AutoRow(EditorGUIUtility.currentViewWidth))\n                {\n                    row.Button(DP_Loc.T("ssScan"), RunStaticScan);\n                    //* Block comment translated: NOTE: 把“设所有Static Flags”放在同一行，空间不足时自动换到下一行 *// translated\n                    row.Button(DP_Loc.T("ssSetFlagsAll"), () => _setAllFlags = !_setAllFlags);\n                    GUILayout.FlexibleSpace();\n                    //* Block comment translated: NOTE: 给切换一个可视提示 *// translated\n                    GUILayout.Label(_setAllFlags ? "(ON)" : "(OFF)", GUILayout.Width(40));\n                }\n\n                using (var row = new AutoRow(EditorGUIUtility.currentViewWidth))\n                {\n                    row.Button(DP_Loc.T("ssIncludeRenderer"), () => _includeRendererOnly = !_includeRendererOnly);\n                    row.Button(DP_Loc.T("ssDynAnimator"),     () => _dynAnimator       = !_dynAnimator);\n                    row.Button(DP_Loc.T("ssDynAudio"),        () => _dynAudio          = !_dynAudio);\n                    row.Button(DP_Loc.T("ssDynParticle"),     () => _dynParticles      = !_dynParticles);\n                    row.Button(DP_Loc.T("ssDynReflProbe"),    () => _dynReflProbe      = !_dynReflProbe);\n                }\n\n                using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox))\n                {\n                    GUILayout.Label($"{DP_Loc.T("ssLikelyStatic")}: {_likelyStaticNotStatic.Count}");\n                    using (var row = new AutoRow(EditorGUIUtility.currentViewWidth))\n                    {\n                        row.Button(DP_Loc.T("ssSelectStatic"), () => SelectList(_likelyStaticNotStatic));\n                        row.Button(DP_Loc.T("ssFixStatic"),    () => MarkStatic(_likelyStaticNotStatic, _setAllFlags));\n                    }\n\n                    GUILayout.Space(4);\n                    GUILayout.Label($"{DP_Loc.T("ssLikelyDynamic")}: {_likelyDynamicStaticOn.Count}");\n                    using (var row = new AutoRow(EditorGUIUtility.currentViewWidth))\n                    {\n                        row.Button(DP_Loc.T("ssSelectDynamic"), () => SelectList(_likelyDynamicStaticOn));\n                        row.Button(DP_Loc.T("ssClearDynamic"),  () => ClearStatic(_likelyDynamicStaticOn));\n                    }\n                }\n            }\n        }\n\n        //* Block comment translated: NOTE: —— 打开正确的 Bakery 窗口：先反射找类型（无日志），找不到再提示 —— *// translated\n        private static void OpenBakeryRenderWindow()\n        {\n            string[] typeCandidates =\n            {\n                "ftRenderLightmaps","ftRenderLightmap","ftBuildGraphics","BakeryWindow","Bakery.RenderLightmapsWindow"\n            };\n            foreach (var tn in typeCandidates)\n            {\n                var t = DP_Utils.GetTypeByName(tn);\n                if (t != null && typeof(EditorWindow).IsAssignableFrom(t))\n                {\n                    EditorWindow.GetWindow(t, false, "Bakery", true);\n                    return;\n                }\n            }\n            foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())\n            {\n                Type[] types;\n                try { types = asm.GetTypes(); } catch { continue; }\n                foreach (var t in types)\n                {\n                    if (!typeof(EditorWindow).IsAssignableFrom(t)) continue;\n                    string n = t.FullName.ToLowerInvariant();\n                    if ((n.Contains("bakery") || n.Contains("ft")) && (n.Contains("render") || n.Contains("lightmap")))\n                    {\n                        EditorWindow.GetWindow(t, false, "Bakery", true);\n                        return;\n                    }\n                }\n            }\n            EditorUtility.DisplayDialog("Bakery",\n                "Could not locate the 'Render Lightmaps' window via reflection. Please open it from the Bakery menu in your project.",\n                DP_Loc.T("ok"));\n        }\n\n        // —— Collect and group lights ——\n        private static void CollectAndGroup()\n        {\n            List<Light> lights = GetLightsByScope();\n            if (lights.Count == 0)\n            {\n                EditorUtility.DisplayDialog("Bakery", "No lights found.", DP_Loc.T("ok"));\n                return;\n            }\n\n            GameObject group = null;\n            if (_groupUnder)\n            {\n                group = GameObject.Find(_groupName) ?? new GameObject(_groupName);\n                Undo.RegisterCreatedObjectUndo(group, "Create Bakery Group");\n            }\n\n            var processedRoots = new HashSet<GameObject>();\n            int moved = 0;\n\n            try\n            {\n                for (int i = 0; i < lights.Count; i++)\n                {\n                    var l = lights[i];\n                    if (EditorUtility.DisplayCancelableProgressBar("Collect & Group Lights", l.name, (float)i / lights.Count)) break;\n                    if (_ignoreDirectional && l.type == LightType.Directional) continue;\n\n                    if (_unpackPrefabs)\n                    {\n                        var root = PrefabUtility.GetOutermostPrefabInstanceRoot(l.gameObject);\n                        if (root != null && !processedRoots.Contains(root))\n                        {\n                            processedRoots.Add(root);\n                            try { PrefabUtility.UnpackPrefabInstance(root, PrefabUnpackMode.Completely, InteractionMode.AutomatedAction); }\n                            catch { }\n                        }\n                    }\n\n                    if (_groupUnder && group != null && l.transform.parent != group.transform)\n                    {\n                        Undo.SetTransformParent(l.transform, group.transform, "Group Lights");\n                        moved++;\n                    }\n                }\n            }\n            finally { EditorUtility.ClearProgressBar(); }\n\n            EditorUtility.DisplayDialog("Bakery", $"{DP_Loc.T("bakCollectGroup")} -> {DP_Loc.T("bakDone")}\nMoved: {moved}", DP_Loc.T("ok"));\n        }\n\n        // —— Convert to Bakery lights and disable originals ——\n        private static void ConvertAllToBakery()\n        {\n            List<Light> lights = GetLightsByScope();\n            if (lights.Count == 0)\n            {\n                EditorUtility.DisplayDialog("Bakery", "No lights found.", DP_Loc.T("ok"));\n                return;\n            }\n\n            var tpFtLight = DP_Utils.GetTypeByName("ftLight");\n            if (tpFtLight == null)\n            {\n                EditorUtility.DisplayDialog("Bakery", "Type 'ftLight' not found.", DP_Loc.T("ok"));\n                return;\n            }\n\n            int converted = 0, skipped = 0;\n            Undo.IncrementCurrentGroup(); int g = Undo.GetCurrentGroup();\n\n            try\n            {\n                for (int i = 0; i < lights.Count; i++)\n                {\n                    var l = lights[i];\n                    if (EditorUtility.DisplayCancelableProgressBar("Convert -> Bakery", l.name, (float)i / lights.Count)) break;\n                    if (_ignoreDirectional && l.type == LightType.Directional) { skipped++; continue; }\n\n                    var comp = l.GetComponent(tpFtLight);\n                    if (comp == null)\n                    {\n                        comp = l.gameObject.AddComponent(tpFtLight);\n                        Undo.RegisterCreatedObjectUndo((UnityEngine.Object)comp, "Add ftLight");\n                    }\n\n                    TrySet(tpFtLight, comp, "color", l.color);\n                    TrySet(tpFtLight, comp, "intensity", l.intensity);\n                    TrySet(tpFtLight, comp, "samples", 64);\n                    TrySet(tpFtLight, comp, "selfShadow", true);\n\n                    int bakerType = l.type switch\n                    {\n                        LightType.Point       => 0,\n                        LightType.Directional => 1,\n                        LightType.Spot        => 2,\n                        LightType.Area        => 4,\n                        _ => 0\n                    };\n                    TrySet(tpFtLight, comp, "lightType", bakerType);\n\n                    if (l.type == LightType.Spot) { TrySet(tpFtLight, comp, "cutoff", l.spotAngle); }\n                    if (l.type == LightType.Area)\n                    {\n                        var sz = l.areaSize;\n                        TrySet(tpFtLight, comp, "sizeX", sz.x);\n                        TrySet(tpFtLight, comp, "sizeY", sz.y);\n                    }\n\n                    if (_disableOriginal) l.enabled = false;\n                    converted++;\n                }\n            }\n            finally\n            {\n                Undo.CollapseUndoOperations(g);\n                EditorUtility.ClearProgressBar();\n            }\n\n            EditorUtility.DisplayDialog("Bakery", $"Converted: {converted}\nSkipped: {skipped}", DP_Loc.T("ok"));\n        }\n\n        // —— Area Light -> Bakery Area only (safer fix) ——\n        private static void ConvertUnityAreaToBakeryOnSelection()\n        {\n            var sels = Selection.gameObjects;\n            if (sels == null || sels.Length == 0)\n            {\n                EditorUtility.DisplayDialog("Bakery", "No selection.", DP_Loc.T("ok"));\n                return;\n            }\n\n            var ftLight = DP_Utils.GetTypeByName("ftLight");\n            if (ftLight == null)\n            {\n                EditorUtility.DisplayDialog("Bakery", "Type 'ftLight' not found.", DP_Loc.T("ok"));\n                return;\n            }\n\n            int converted = 0;\n            Undo.IncrementCurrentGroup(); int g = Undo.GetCurrentGroup();\n\n            try\n            {\n                var lights = new List<Light>();\n                foreach (var go in sels) lights.AddRange(go.GetComponentsInChildren<Light>(true));\n\n                for (int i = 0; i < lights.Count; i++)\n                {\n                    var l = lights[i];\n                    if (EditorUtility.DisplayCancelableProgressBar("Convert Area -> Bakery", l.name, (float)i / lights.Count)) break;\n                    if (l.type != LightType.Area) continue;\n\n                    var comp = l.GetComponent(ftLight);\n                    if (comp == null)\n                    {\n                        comp = l.gameObject.AddComponent(ftLight);\n                        Undo.RegisterCreatedObjectUndo((UnityEngine.Object)comp, "Add ftLight");\n                    }\n\n                    TrySet(ftLight, comp, "color", l.color);\n                    TrySet(ftLight, comp, "intensity", l.intensity);\n                    TrySet(ftLight, comp, "samples", 64);\n                    TrySet(ftLight, comp, "selfShadow", true);\n\n                    var size = l.areaSize;\n                    TrySet(ftLight, comp, "sizeX", size.x);\n                    TrySet(ftLight, comp, "sizeY", size.y);\n                    TrySet(ftLight, comp, "lightType", 4);\n\n                    if (_disableOriginal) l.enabled = false;\n                    converted++;\n                }\n            }\n            finally\n            {\n                Undo.CollapseUndoOperations(g);\n                EditorUtility.ClearProgressBar();\n            }\n\n            EditorUtility.DisplayDialog("Bakery", $"Converted: {converted}", DP_Loc.T("ok"));\n        }\n\n        // —— Static scanner ——\n        private static void RunStaticScan()\n        {\n            _likelyStaticNotStatic.Clear();\n            _likelyDynamicStaticOn.Clear();\n\n            IEnumerable<GameObject> cand = UnityEngine.Object\n                .FindObjectsOfType<Collider>(true)\n                .Select(c => c.gameObject);\n\n            if (_includeRendererOnly)\n            {\n                var renderers = UnityEngine.Object.FindObjectsOfType<MeshRenderer>(true)\n                    .Select(r => r.gameObject);\n                cand = cand.Concat(renderers);\n            }\n\n            var set = new HashSet<GameObject>(cand);\n\n            var tUdon       = DP_Utils.GetTypeByName("VRC.Udon.UdonBehaviour") ?? DP_Utils.GetTypeByName("UdonSharp.UdonSharpBehaviour");\n            var tPickup     = DP_Utils.GetTypeByName("VRC.SDK3.Components.VRCPickup");\n            var tObjSync    = DP_Utils.GetTypeByName("VRC.SDK3.Components.VRCObjectSync");\n\n            foreach (var go in set)\n            {\n                if (go == null) continue;\n\n                bool isDynamic = HasDynamicMarkers(go, tUdon, tPickup, tObjSync);\n                bool looksSimple = OnlyHasSimpleComponents(go);\n\n                if (isDynamic)\n                {\n                    if (go.isStatic) _likelyDynamicStaticOn.Add(go);\n                }\n                else if (looksSimple)\n                {\n                    if (!go.isStatic) _likelyStaticNotStatic.Add(go);\n                }\n            }\n\n            EditorUtility.DisplayDialog(\n                "Static Scanner",\n                $"{DP_Loc.T("ssLikelyStatic")}: {_likelyStaticNotStatic.Count}\n" +\n                $"{DP_Loc.T("ssLikelyDynamic")}: {_likelyDynamicStaticOn.Count}",\n                DP_Loc.T("ok"));\n        }\n\n        private static bool HasDynamicMarkers(GameObject go, Type tUdon, Type tPickup, Type tObjSync)\n        {\n            if (go.GetComponent<Rigidbody>() != null || go.GetComponent<Rigidbody2D>() != null)\n                return true;\n\n            if (tUdon != null && go.GetComponent(tUdon) != null) return true;\n            if (tPickup != null && go.GetComponent(tPickup) != null) return true;\n            if (tObjSync != null && go.GetComponent(tObjSync) != null) return true;\n\n            if (_dynAnimator && go.GetComponent<Animator>() != null) return true;\n            if (_dynAudio && go.GetComponent<AudioSource>() != null) return true;\n            if (_dynParticles && go.GetComponent<ParticleSystem>() != null) return true;\n            if (_dynReflProbe && go.GetComponent<ReflectionProbe>() != null) return true;\n\n            var monos = go.GetComponents<MonoBehaviour>();\n            foreach (var m in monos)\n            {\n                if (m == null) return true; // NOTE: Missing 脚本 -> 也视作动态 // translated\n                var asm = m.GetType().Assembly.GetName().Name;\n                if (!asm.StartsWith("UnityEngine", StringComparison.Ordinal))\n                    return true;\n            }\n            return false;\n        }\n\n        private static bool OnlyHasSimpleComponents(GameObject go)\n        {\n            var comps = go.GetComponents<Component>();\n            foreach (var c in comps)\n            {\n                if (c == null) return false; // NOTE: Missing 脚本 -> 非简单 // translated\n                var t = c.GetType();\n\n                if (t == typeof(Transform) || t == typeof(MeshFilter) || t == typeof(LODGroup))\n                    continue;\n\n                if (t == typeof(MeshRenderer) ||\n                    t == typeof(BoxCollider) || t == typeof(MeshCollider) ||\n                    t == typeof(CapsuleCollider) || t == typeof(SphereCollider))\n                    continue;\n\n                return false;\n            }\n            return true;\n        }\n\n        private static void SelectList(List<GameObject> list)\n        {\n            Selection.objects = list.Where(o => o != null).Cast<UnityEngine.Object>().ToArray();\n        }\n\n        private static void MarkStatic(List<GameObject> list, bool allFlags)\n        {\n            if (list == null || list.Count == 0) return;\n\n            Undo.IncrementCurrentGroup(); int g = Undo.GetCurrentGroup();\n            foreach (var go in list)\n            {\n                if (go == null) continue;\n\n                var flags = allFlags\n                    ? (StaticEditorFlags)~0\n                    : (StaticEditorFlags.BatchingStatic |\n                       StaticEditorFlags.ContributeGI |\n                       StaticEditorFlags.ReflectionProbeStatic |\n                       StaticEditorFlags.OccluderStatic |\n                       StaticEditorFlags.OccludeeStatic);\n\n                GameObjectUtility.SetStaticEditorFlags(go, flags);\n                EditorUtility.SetDirty(go);\n            }\n            Undo.CollapseUndoOperations(g);\n        }\n\n        private static void ClearStatic(List<GameObject> list)\n        {\n            if (list == null || list.Count == 0) return;\n\n            Undo.IncrementCurrentGroup(); int g = Undo.GetCurrentGroup();\n            foreach (var go in list)\n            {\n                if (go == null) continue;\n                GameObjectUtility.SetStaticEditorFlags(go, 0);\n                EditorUtility.SetDirty(go);\n            }\n            Undo.CollapseUndoOperations(g);\n        }\n\n        private static List<Light> GetLightsByScope()\n        {\n            var list = new List<Light>();\n            if (_scope == 0) list.AddRange(UnityEngine.Object.FindObjectsOfType<Light>(true));\n            else\n            {\n                var sels = Selection.gameObjects;\n                if (sels != null)\n                    foreach (var go in sels) list.AddRange(go.GetComponentsInChildren<Light>(true));\n            }\n            return list;\n        }\n\n        private static void TrySet(Type t, object inst, string fieldOrProp, object value)\n        {\n            try\n            {\n                var f = t.GetField(fieldOrProp, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);\n                if (f != null) { f.SetValue(inst, value); return; }\n                var p = t.GetProperty(fieldOrProp, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);\n                if (p != null && p.CanWrite) { p.SetValue(inst, value, null); return; }\n            }\n            catch { /* Block comment translated: 单项失败忽略 */ }\n        }\n\n        // NOTE: —— 轻量“自动换行行容器”（仅在本文件内部使用）—— // translated\n        private struct AutoRow : System.IDisposable\n        {\n            float _viewW, _used, _gap;\n            readonly GUILayoutOption _h22;\n            public AutoRow(float viewWidth, float gap = 4f, float btnH = 22f)\n            {\n                _viewW = viewWidth - 32f;\n                _used = 0f;\n                _gap  = gap;\n                _h22  = GUILayout.Height(btnH);\n                EditorGUILayout.BeginHorizontal();\n            }\n            float NeedWidth(string label)\n            {\n                var s = GUI.skin.button;\n                var size = s.CalcSize(new GUIContent(label));\n                return Mathf.Max(100f, size.x + 16f);\n            }\n            void BreakIfNeed(float w)\n            {\n                if (_used > 0f && _used + w > _viewW)\n                {\n                    EditorGUILayout.EndHorizontal();\n                    EditorGUILayout.BeginHorizontal();\n                    _used = 0f;\n                }\n            }\n            public bool Button(string label, System.Action onClick)\n            {\n                float need = NeedWidth(label);\n                BreakIfNeed(need);\n                bool hit = GUILayout.Button(label, _h22, GUILayout.MinWidth(need));\n                _used += need + _gap;\n                if (hit) onClick?.Invoke();\n                return hit;\n            }\n            public void Dispose() { EditorGUILayout.EndHorizontal(); }\n        }\n    }\n}\n#endif